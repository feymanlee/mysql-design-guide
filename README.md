<h1 align="center">MySql 数据库设计规范</h1>
> 本规范旨在帮助或指导 RD、QA、OP 等技术人员做出适合线上业务的数据库设计。在数据库表设计，数据库变更和流程处理、SQL 编写等方面予以规范，从而为系统稳定、健康地运行提供保障。

## 能愿动词的使用
本文档中使用了大量的「能愿动词」，为了避免歧义，对应的解释如下：

- 必须 (MUST)：绝对，严格遵循，请照做，无条件遵守；
- 严禁 (MUST NOT)：禁令，严令禁止；
- 应该 (SHOULD) ：强烈建议这样做，但是不强求；
- 不该 (SHOULD NOT)：强烈不建议这样做，但是不强求；
- 可以 (MAY) 和 可选 (OPTIONAL) ：选择性高一点，在这个文档内，此词语使用较少； 

## 命名规范
### 基本命名原则
  - **必须** 使用有意义的英文词汇，词汇中间以 **下划线** 分隔（不要用拼音）
  - **必须** 使用 **英文字母**、**数字**、**下划线**，并以 **英文字母** 开头
  - 库、表、字段命名 **必须** 全部采用 **小写**
  - **不该** 使用驼峰式命名
  - **不该** 使用 MySQL 的保留字和关键字，如 `desc`、 `index` 等
  - 如无特殊需求，命名 **不该** 超过 `32` 个字符
  - **应该** 使用 **名词**
  - 数据库，数据表使用前缀时：
    - 临时库、表名 **应该** 以为	`tmp_` 前缀，并以 **日期** 为后缀
    - 备份库、表 **应该** 以为 `bak_` 前缀，并以 **日期** 为后缀
    
  
> #### 为什么库、表、字段全部采用小写? 
> 在 MySQL 中，数据库和表对就于那些目录下的目录和文件。因而，操作系统的敏感性决定数据库和表命名的大小写敏感。 
> - Windows 下是不区分大小写的
> - Linux 下大小写规则：
	- 数据库名与表名是严格区分大小写的
	- 表的别名是严格区分大小写的
	- 列名与列的别名在所有的情况下均是忽略大小写的
	- 变量名也是严格区分大小写的
  
        
> #### 如果已经设置了驼峰式的命名如何解决？
> 需要在 MySQL 的配置文件 my.ini 中增加 `lower_case_table_names = 1` 即可。
  
### 数据库命名
  - **必须** 使用见名知意的词汇，推荐使用 「项目名」或「模块名」
  - 使用 **单数**
  - 如存在分库，分库名称 **应该** 以「库名_编号」，编号从 `0` 开始递增，比如 `good_001`

### 数据表命名
  - 同一个模块的表 **应该** 使用相同的前缀，表名称尽可能表达其含义。如日志表均以 `log_` 开头
  - 使用 **复数**
  - 如存在分表，分表名称 **应该** 以「表名_编号」，编号从 `0` 开始递增，比如 `goods_001`

### 字段命名
  - 表达其实际含义的英文单词或简写。布尔意义的字段 **应该** 以 `is_` 作为前缀，后接动词过去分词
  - 各表之间具有相同意义的字段 **应该** 同名
  - 各表之间相同意义的字段，**应该** 以去掉模块前缀的「表名_字段名」命名
  - 表的主键一般都约定成为 `id`
  - 外键 **应该** 使用 `xxx_id` 的方式来表明，`xxx` 代表外键表名

### 索引命名
  - 非唯一索引 **应该** 按照 「idx\_字段名 1\_字段名 2_ ... 字段名 n 」进行命名
  - 唯一索引 **应该** 按照 「idx\_字段名 1\_字段名 2_ ... 字段名 n 」 进行命名

### 约束命名
  - 主键约束 **应该** 以 「pk_表名称」命名
  - 唯一约束 **应该** 以「uk_表名称_字段名」命名（应用程序中 **必须** 有唯一性检查逻辑，避免数据插入、更新失败）

## 库设计规范
### 引擎
  - 日志及报表类库 **应该** 用 MyISAM
  - 与交易，审核，金额相关的库 **应该** 用 InnoDB 引擎
  - 如无特殊说明，建库时 **必须** 采用 InnoDB 引擎
  - 新建数据库时 **必须** 显式制定数据表引擎

### 字符集与排序规则
  - **应该** 使用 `utf8mb4` 字符集
  - **应该** 使用 `utf8mb4_general_ci` 排序规则
### 其他
  - **必须** 写 `comment` 
  
## 表设计规范
### 引擎

表引擎的选择取决于实际应用场景。

 - 日志及报表类表 **应该** 用 MyISAM
 - 与交易，审核，金额相关的表 **应该** 用 InnoDB 引擎
 - 如无特殊说明，建表时 **必须** 采用 InnoDB 引擎
 - 新建数据表时 **必须** 显式制定数据表引擎

附：[《MySQL存储引擎－－MyISAM与InnoDB区别》](https://segmentfault.com/a/1190000008227211)

### 字符集与排序规则
 - **应该** 使用 `utf8mb4` 字符集
 - **应该** 使用 `utf8mb4_general_ci` 排序规则（由于数据库定义使用了默认，数据表可以不再定义，但为保险起见，建议都写上）


> #### 为什么字符集不选择 utf8，排序规则不使用 utf8_general_ci？
> 采用 utf8 编码的 MySQL 无法保存占位是 4 个字节的 Emoji 表情。为了使后端的项目，全面支持客户端输入的 Emoji 表情，升级编码为 utf8mb4 是最佳解决方案。对于 JDBC 连接串设置了characterEncoding 为 utf8 或者做了上述配置仍旧无法正常插入 Emoji 数据的情况，需要在代码中指定连接的字符集为 utf8mb4。

### 字段规范
 - 所有表、字段 **必须** 应用 `comment` 列属性来描述此表、字段所代表的真正含义，枚举值需将该字段中使用的内容都定义出来
 - 如无特殊需求，表中的第一个字段 **应该** 命名为 `id`, 设为 **主键** 且为 **自动增长**，类型应该为 **无符号整型**
 - **严禁** 在非事务内作为上下文作为条件进行数据传递
 - **严禁** 使用 `varchar` 类型作为主键
 -  如无特殊需求，表中 **必须** 包含记录「创建时间」和 「更新时间」的字段，建议名称（`created_at`，`updated_at`）
 -  如无特殊需求，**应该** 使用「软删除」。数据表中需要存在用来标识数据是否被删除的字段，原则上数据库数据不允许物理删除
 -  如无特殊需求，所有字段都 **必须** 设置 `not null`，并设置 **默认值**
 
> #### 为什么要将字段设置为 `not null`
> - 在 MySQL 数据库中，空值是不占用空间的，而 `null` 是占用空间的（一个字节）。
> - MySQL 表的列中包含 `null` 的话，该列就不会包含在索引中，也就是说使用索引是无效的。
> -  如果一列数据中包含 `null` , 你再使用 `!=`,`<>`,`not in`,`not like` 等负向查询条件的时候为 `null` 的行会被忽略（非 null 的话只能使用 is not null），这个会引起很多很诡异的数据问题
 
> #### 默认值设置规范
> - 数值型设置默认值为 `0`
> - 字符串设置默认值为空字符串
> - 枚举类型根据业务需求设置对应的默认值
 
> #### 什么情况下需要设置为 `null`
> - 字段类型是 `text`、`blob`、`timestamp`、`image`、`datetime`、`smalldatetime`、`uniqueidentifier`、 `binary`、`sql_variant`、`binary`、`varbinary` 时，需要将默认值设置为 `null`；
 
 - 整形定义中不添加长度，使用 `int`，而不是 `int(M)`

> #### int[M]，M 值代表什么含义？
> 数值类型括号后面的数字只是表示宽度而跟存储范围没有关系。INT(4) 和 INT(10) 其取值范围分别是 (-9999 ~ 9999) 和 (-9999999999 ~ 9999999999)，这种理解是错误的，整型中的 M 值与 ZEROFILL 属性结合使用时可以实现列值等宽。不管 INT(M) 中 M 值是多少，其取值范围还是 -2147483648 到 2147483647 （有符号时），0 到 4294967295 （无符号时）。显示宽度并不限制可以在列内保存的值的范围，也不限制超过列的指定宽度的值的显示。当结合可选扩展属性 ZEROFILL 使用时默认补充的空格用零代替。例如：对于声明为 INT(5) ZEROFILL 的列，值 4 检索为 00004。请注意如果在整数列保存超过显示宽度的一个值，当 MySQL 为复杂联接生成临时表时会遇到问题，因为在这些情况下 MySQL 相信数据适合原列宽度，如果为一个数值列指定 ZEROFILL, MySQL 自动为该列添加 UNSIGNED 属性。

 - **不该** 使用外键约束
 
> #### 为什么不使用外键约束
> - 外键用来保护参照完整性，可在业务端实现
> - 对父表和子表的操作会相互影响，降低可用性
> - INNODB 本身对 online DDL 的限制

### 字段数据类型选择
 - 能用 `int` 的就不用 `char` 或 `varchar`
 - 能用 `tinyint` 的就不用 `int`
 - 使用 `unsigned` 存储非负数值，如（id，次数等）
 - 根据需求使用较短数据类型，比如取值范围为 0-80 时，使用 `tinyint unsigend`
 - 存储精确浮点数 **必须** 使用 `decimal` 替代 `float` 和 `double`
 - 存储年 **应该** 使用 `year` 类型
 - 存储日期 **应该** 使用 `date` 类型
 - 存储时间（精确到秒） **应该** 使用 `timestamp` 类型，因为 `timestamp` 占用 4 字节，`datetime` 占用 8 个字节
 
> #### `datetime` 与 `timestamp` 有什么不同？
  - 相同点：timestamp 列的显示格式与 datetime 列相同。显示宽度固定在 19 字符，并且格式为 YYYY-MM-DD HH:MM:SS。
  - 不同点：
    - timestamp
      - 4 个字节储存，时间范围：1970-01-01 08:00:01 ~ 2038-01-19 11:14:07
      - 值以 UTC 格式保存，涉及时区转化 ，存储时对当前的时区进行转换，检索时再转换回当前的时区
    - datetime
      - 8个字节储存，时间范围：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
      - 实际格式储存，与时区无关
      
      
> #### 如何使用 TIMESTAMP 的自动赋值属性？
> - 将当前时间作为 ts 的默认值：ts timestamp default current_timestamp
> - 当行更新时，更新 ts 的值：ts times default  on update current_timestamp
> - 可以将 1 和 2 结合起来：ts timestamp default current_timestamp on update current_timestamp


 - **应该** 使用 `int unsigend` 类型存储 IPV4 地址
 
> #### 如何使用 `int unsigned` 存储 IPV4 地址？
> 使用 `int unsigned` 而不是 `char(15)` 来存储 IPV4 地址，通过 MySQL 函数 `inet_ntoa` 和 `inet_aton` 来进行转化。IPV6 地址目前没有转化函数，需要使用 `decimal` 或者两个 `big int` 来存储。

 - **不该** 使用 `text`、`blob` 类型
 - **严禁** 在数据库中使用 `varbinary`、`blog` 存储图片、文件等。建议使用其他方式存储（TFS/SFS），MySQL 只保存指针（路径）信息。
 - 单条记录大小 **严禁** 超过 8k（列长度(中文) \*3(UTF8) + 列长度(英文)*1）
 - **应该** 使用 `varbinary` 存储大小写敏感的变长字符串

> #### 什么时候用 `char`，什么时候用 `varchar`？
> - `cahr` 和 `varchar` 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。`char` 和 `varchar` 类型声明的长度表示你想要保存的最大字符数。例如，`char(30)` 可以占用 30 个字符。
    - `char` 列的长度固定为创建表时声明的长度。长度可以为从0到255的任何值。当保存 `char` 值时，在它们的右边填充空格以达到指定的长度。当检索到 `char` 值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。
    - `varchar` 列中的值为可变长字符串。长度可以指定为 0 到 65535 之间的值。(`varchar` 的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是 65532 字节）。
> - 同 `char` 对比，`varchar` 值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过 255，则使用两个字节)。`varchar` 值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准 SQL。
> - `char` 适合存储用户密码的 MD5 哈希值，它的长度总是一样的。对于经常改变的值， `char` 也好于 `varchar`，因为固定长度的行不容易产生硬盘碎片，对于很短的列， `char` 的效率也高于 `varchar`，`char(1)` 字符串对于单字节字符集只会占用一个字节，但是 `varchar(1)` 则会占用2个字节，因为需要 1 个字节用来存储长度信息。

## 索引设计规范

MySQL 的查询速度依赖良好的索引设计，因此索引对于高性能至关重要。合理的索引会加快查询速度（包括 UPDATE 和    DELETE 的速度，MySQL 会将包含该行的 page 加载到内存中，然后进行 UPDATE 或者 DELETE 操作），不合理的索引会降低速度。MySQL 索引查找类似于新华字典的拼音和部首查找，当拼音和部首索引不存在时，只能通过一页一页的翻页来查找。当 MySQL 查询不能使用索引时，MySQL会进行全表扫描，会消耗大量的 IO。索引的用途：去重、加速定位、避免排序、覆盖索引。

> #### 什么是覆盖索引（Covering Index）？
> InnoDB 存储引擎中，Secondary Index（非主键索引，也称为辅助索引）中没有直接存储行地址，而是存储主键值。如果用户需要查询 Secondary Index中所不包含的数据列时，需要先通过 Secondary Index 查找到主键值，然后再通过主键查询到其他数据列，因此需要查询两次。覆盖索引的概念就是查询可以通过在一个索引中完成，覆盖索引效率会比较高，主键查询是天然的覆盖索引。合理的创建索引以及合理的使用查询语句，当使用到覆盖索引时可以获得性能提升。比如 `SELECT email,uid FROM user_email WHERE uid=xx`，如果 uid 不是主键，适当时候可以将索引添加为 `index(uid,email)`，以获得性能提升。

### 索引数量
 - 索引数量控制，单张表中索引数量不超过 5 个，单个索引中的字段数不超过 5 个
 
> #### 为什么一张表中不能存在过多的索引？
> InnoDB 的secondary index使用b+tree来存储，因此在UPDATE、DELETE、INSERT的时候需要对b+tree进行调整，过多的索引会减慢更新的速度。

### 索引选取原则
 - 综合评估数据密度和分布
 - 考虑查询和更新比例
 - 对字符串 **应该** 使用前缀索引，前缀索引长度 **不该** 超过8个字符，建议优先考虑前缀索引，必要时可添加伪列并建立索引。
 
> #### 什么是前缀索引？
> 前缀索引说白了就是对文本的前几个字符（具体是几个字符在建立索引时指定）建立索引，这样建立起来的索引更小，所以查询更快。 前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处，MySQL 不能在 `order by` 或 `group by` 中使用前缀索引，也不能把它们用作覆盖索引（Covering Index）。
> 建立前缀索引的语法：```sql ALTER TABLE table_name ADD KEY(column_name(prefix_length))```;

 - **不该** 索引 `blob`、`text` 等字段，不要索引大型字段，这样做会让索引占用太多的存储空间
 - **不该** 使用更新频繁的列
 - **不该** 选择字符串列
 - **不该** 使用 UUID MD5 HASH 列
 - **应该** 使用非空的唯一列
 - **应该** 选择自增或发号器
 - 重要的 SQL **必须** 被索引，核心 SQL 优先考虑覆盖索索引
  - UPDATE、DELETE 语句的 WHERE 条件列
  - SELECT 经常使用的 WHERE 条件列
  - ORDER BY、GROUP BY、DISTINCT 的字段
  - 多表 JOIN 的连接条件字段
 - **应该** 区分度最大的字段放在前面
  - 选择筛选性更优的字段放在最前面，比如单号、userid 等，type，status 等筛选性一般的不建议放在最前面
 - 索引 **应该** 根据左前缀原则
  - 当建立一个联合索引 (a,b,c)，则查询条件里面只有包含 (a) 或 (a,b) 或 (a,b,c) 的时候才能走索引,(a,c) 作为条件的时候只能使用到 a 列索引，所以这个时候要确定 a 的返回列一定不能太多，不然语句设计就不合理，(b,c) 则不能走索引
 - 合理创建联合索引（避免冗余），(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)

### 索引禁忌

 - **不该** 在低基数列上建立索引，例如「性别」
 - **不该** 在索引列进行数学运算和函数运算
 - **不该** 索引常用的小型表

### MYSQL 中索引的限制
 - MYISAM 存储引擎索引长度的总和不能超过 1000 字节
 - `blob` 和 `text` 类型的列只能创建前缀索引
 - MYSQL 目前不支持函数索引
 - 使用不等于 (`!=` 或者 `<>`) 的时候, MYSQL 无法使用索引
 - 过滤字段使用函数运算 (如 `abs (column)`) 后, MYSQL 无法使用索引
 - `join` 语句中 `join` 条件字段类型不一致的时候 MYSQL 无法使用索引
 - 使用 `like` 操作的时候如果条件以通配符开始 (如 ‘%abc…’)时, MYSQL 无法使用索引
 - 使用非等值查询的时候, MYSQL 无法使用 `hash` 索引。

## 语句设计规范

 - **应该** 使用预编译语句
  - 只传参数，比传递 SQL 语句更高效
  - 一次解析，多次使用
  - 降低 SQL 注入概率

 -  避免隐式转换
  - 会导致索引失效

 - 充分利用前缀索引
  - **必须** 是最左前缀
  - **不该** 同时用到两个范围条件
  - **不该** 使用 `%` 前导的查询，如 `like '%ab'`
  
 -  **不该** 使用负向查询，如 not in/like
  - 无法使用索引，导致全表扫描
  - 全表扫描导致 buffer pool 利用率降低
  
 - 避免使用大表的 JOIN
  - MySQL 最擅长的是单表的主键/二级索引查询
  - JOIN 消耗较多内存，产生临时表

 - **不该** 在数据库中进行数学运算
  - MySQL 不擅长数学运算和逻辑判断
  - 无法使用索引

 - 减少与数据库的交互次数
  - INSERT … ON DUPLICATE KEY UPDATE
  - REPLACE INTO、INSERT IGNORE 、INSERT INTO VALUES(),(),()
  - UPDATE … WHERE ID IN(10,20,50,…)
  
 - 合理的使用分页
  - 限制分页展示的页数
  - 采用延迟关联
  
> #### 如何正确的使用分页？
> 假如有类似下面分页语句：```SELECT * FROM table  ORDER BY id LIMIT 10000, 10```。
> 由于 MySQL 里对 LIMIT OFFSET 的处理方式是取出 OFFSET+LIMIT 的所有数据，然后去掉 OFFSET，返回底部的 LIMIT。所以，在 OFFSET 数值较大时，MySQL 的查询性能会非常低。可以使用 `id > n` 的方式进行解决：
> 使用id > n 的方式有局限性，对于id不连续的问题，可以通过翻页的时候同时传入最后一个id方式来解决。
> 这种方式比较大的缺点是，如果在浏览中有插入/删除操作，翻页不会更新，而总页数可能仍然是根据新的count(*) 来计算，最终可能会产生某些记录访问不到。为了修补这个问题，可以继续引入当前页码以及在上次翻页以后是否有插入/删除等影响总记录数的操作并进行缓存。
> 其他变种方式：
```select * from table where id >= (select id from table order by id limit #offset#, 1) ``` 

 - **不该** 使用大 SQL，拆分成小 SQL
  - 充分利用 QUERY CACHE
  - 充分利用多核 CPU
 - **应该** 使用 `in` 代替 `or`
 - `in` 的值 **不该** 超过 1000 个
 - **严禁** 使用 `order by rand()`，应该先生成随机数，然后载根据随机数排序
 - **应该** 使用 `explain` 诊断，避免生成临时表

> EXPLAIN 语句（在 MySQL 客户端中执行）可以获得 MySQL 如何执行 SELECT 语句的信息。通过对 SELECT 语句执行 EXPLAIN，可以知晓 MySQL 执行该 SELECT 语句时是否使用了索引、全表扫描、临时表、排序等信息。**应该** 避免 MySQL 进行全表扫描、使用临时表、排序等。

 - 用 `union all` 而不是 `union`
 
> #### union all与 union有什么区别？
> union 和 union all 关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同
> `union` 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。如：
```select * from test_union1 union select * from test_union2```
> 这个 SQL 在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。
> 而 `union all` 只是简单的将两个结果合并后就返回。这样，如果返回的两个结果集中有重复的数据，那么返回的结果集就会包含重复的数据了。
> 从效率上说，`union all` 要比 `union` 快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用 `union all`，如下：```select * from test_union1 union all select * from test_union2```

 - 程序 **应该** 有捕获 SQL 异常的处理机制
 - **严禁** 单条 SQL 语句同时更新多个表
 - **不该** 使用 `select *` ，SELECT 语句只获取需要的字段
  - 消耗 CPU 和 IO、消耗网络带宽
  - 无法使用覆盖索引
  - 减少表结构变更带来的影响
  - 查询数据量过大时，`select`、`join` 可能生成临时表
 - UPDATE、DELETE 语句 **严禁** 使用 LIMIT
 - INSERT 语句 **必须** 显式的指明字段名称，不使用 INSERT INTO table()
 - 多个 INSERT 语句 **必须** 使用 batch 提交。如：（INSERT INTO table VALUES(),(),()……），且 `values` 的个数不超过 500
 - 统计表中记录数时使用 `count(*)`，而不是 `count(primary_key)` 和 `count(1)`（备注：仅针对 MyISAM）
 - 数据更新时 **应该** 使用二级索引先查询出主键，再根据主键进行数据更新
 - **严禁** 使用跨库查询
 - **严禁** 使用子查询，建议将子查询转换成 **关联查询**
 - 针对 `varchar` 类型字段的程序处理，**应该** 验证用户输入，不要超出其预设的长度

## 数据库操作规范
- **严禁** 在线上做数据库压力测试
- **严禁** 从测试、开发环境直连数据库
- **严禁** 使用「存储过程」、「触发器」、「函数」、「视图」、「事件」等高级功能。数据库只做数据存储和标明业务关系，具体业务逻辑相关的处理均由程序实现
- **严禁** 在业务高峰期进行数据批量更新、修改表结构等操作
- 推广活动或上线新功能 **必须** 提前进行流量评估
- 对单表的多次 `alter` 操作 **必须** 合并为一次操作
- 手动执行 SQL 更新、删除数据 **应该** 由两人同时在场，一人操作，一人负责检查
